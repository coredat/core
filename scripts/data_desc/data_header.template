
{{file_warning}}

#ifndef {{data_name.upcase}}_INCLUDED_{{guid}}
#define {{data_name.upcase}}_INCLUDED_{{guid}}


% header_includes.each do |inc|
#include {{inc}}
% end


namespace {{namespace}} {

% if header_add_code != ""

{{header_add_code}}

% end

/*!
  \\brief Auto-generated structure for {{data_type}}
*/
struct {{data_type}}
{
  // Data Key
  util::generic_id *{{key_name}} = nullptr;

  // Properties
  % properties.each do |prop|
    % if prop[:type] == "char_32"
  char *{{prop[:name]}} = nullptr;
    % else
  {{prop[:type]}} *{{prop[:name]}} = nullptr;
    % end
  % end

  // Size information
  size_t size = 0;
  const size_t capacity = 0;

  % if key_auto_inc then
  {{key_type}} key_count = 0;
  % end

  // Memory chunk
  const util::memory_chunk memory = util::memory_chunk();
}; // struct


/*!
  \\brief initialise the {{data_type}} structure, this is will allocate the memory for the keys and properties. Function will take a lock.
  \\param data This structure to initialise.
  \\param size_hint This helps the init function allocate the correct memory.
*/
void
{{data_name}}_init({{data_type}} *data, const size_t size_hint);


/*!
  \\brief Not currently implemented, but will return the memory. Function will take a lock.
  \\param data The data to free.
*/
void
{{data_name}}_free({{data_type}} *data);


/*!
  \\brief Gets the number of items in the container.
  \\param data The structure which to find the size.
*/
size_t
{{data_name}}_get_size(const {{data_type}} *data);


/*!
  \\brief Gets the capacity before new memory is needed.
  \\param data The structure which to find the capacity.
*/
size_t
{{data_name}}_get_capacity(const {{data_type}} *data);


/*!
  \\brief Locks the data, any thing else requiring a lock will have to wait (not implemented).
  \\param data The container to lock.
*/
void
data_lock(const {{data_type}} *data);


/*!
  \\brief Unlocks the data, any pending locks can now proceed (not implemented).
  \\param The container to unlock
*/
void
data_unlock(const {{data_type}} *data);

% if key_auto_inc then
/*!
  \\brief Push back a new element, increases the size by 1. (Does not take a lock).
  \\param data The container which to push back.
  \\param out_index Optional - this will return the inserted location in the container.
  \\return Returns the id of the data.
*/
{{key_type}}
{{data_name}}_push_back({{data_type}} *data, size_t *out_index = nullptr);
% else
/*!
  \\brief Push back a new element, increases the size by 1. (Does not take a lock).
  \\param data The container which to push back.
  \\param key The id to use as a key.
  \\param out_index Optional - this will return the inserted location in the container.
  \\return Returns true if it was successful.
*/
bool
{{data_name}}_push_back({{data_type}} *data, const {{key_type}} key, size_t *out_index = nullptr);
% end


/*!
  \\brief Erase an item from the container, decreases size by 1. (Does not take a lock).
  \\param data The container to erase from.
  \\param key The key which is used to remove the data.
  \\return Returns true if it was successful.
*/
bool
{{data_name}}_erase({{data_type}} *data, const {{key_type}} key);


% if key_search_type == 'linear'
/*!
  \\brief Inserts a new element shuffling down any data that exists in the array. (Does not take a lock).
  \\param data The container to insert into.
  \\param key The key which is used to remove the data.
  \\param insert_point Where to insert. If bigger then the size it will push back.
  \\return Returns true if it was successful.
*/
bool
{{data_name}}_insert({{data_type}} *data, const {{key_type}} key, const size_t insert_index);


% end
/*!
  \\brief Checks to see if a key exists in the container.
  \\param data The container to search.
  \\param key The key to search for.
  \\param out_index Optional - this will return the location of the key.
  \\return Returns true if a key was found.
*/
bool
{{data_name}}_exists(const {{data_type}} *data, const {{key_type}} key, size_t *out_index = nullptr);


% properties.each do |prop|
/*!
  \\brief Getter for {{prop[:name]}}.
  \\param data The container to get information from.
  \\param key The key to search for.
  \\param value The output value, which will be set if the key is found.
  \\return Returns true if the data was found.
*/
bool
% if prop[:multiple] != 1
{{data_name}}_get_{{prop[:name]}}(const {{data_type}} *data, const {{key_type}} key, const {{prop[:type]}} {{prop[:get_indirection]}}value);
% else
{{data_name}}_get_{{prop[:name]}}(const {{data_type}} *data, const {{key_type}} key, {{prop[:type]}} {{prop[:get_indirection]}}value);
% end


/*!
  \\brief Setter for {{prop[:name]}}.
  \\param data The container to update.
  \\param key The key to search for.
  \\param value The new value of the data.
  \\return Returns true if the data was set.
*/
bool
{{data_name}}_set_{{prop[:name]}}({{data_type}} *data,  const {{key_type}} key, const {{prop[:type]}} {{prop[:set_indirection]}}value);


% if prop[:searchable]
/*!
  \\brief Searches for a given value.
  \\param data The container to search.
  \\param value The value which to search for.
  \\param out_key Optional the key for that value.
  \\return Returns true if the data was found.
*/
bool
{{data_name}}_search_{{prop[:name]}}(const {{data_type}} *data, const {{prop[:type]}} {{prop[:set_indirection]}}value, {{key_type}} *out_key = nullptr);


% end
% end
} // ns


#endif // inc guard
